<html>

<head>
  <title>Mission 1</title>
  <meta charset="utf-8" />
</head>

<body>
  <div id="todo-list__1"></div>
  <div id="todo-list__2"></div>
  <div id="todo-list__3"></div>
  
  <script>
     const data1 = [
      {
        text: 'JS 공부하기',
        isCompleted: true
      },
      {
        text: 'JS 복습하기',
        isCompleted: true
      }
    ];
    const nextData1 = [
      {
        text: '프로그래머스 FE 스터디 - 미션1 완료하기',
        isCompleted: false
      },
      {
        text: '프로그래머스 FE 스터디 - 미션1 블로깅하기',
        isCompleted: false
      }
    ]
    const data2 = [
      {
        text: '줄넘기',
        isCompleted: true
      },
      {
        text: '라이딩',
        isCompleted: false,
      },
      {
        text: '책 읽기',
        isCompleted: false,
      }
    ]
    const data3 = [
      {
        text: '점심 먹기',
        isCompleted: true,
      },
      {
        text: '저녁 먹기',
        isCompleted: true,
      }
    ]

    function TodoList(data, id) {

      if(!new.target) {
        throw new Error('new 키워드를 사용해서 인스턴스를 생성하세요.');
      }

      if(!Array.isArray(data) || data.length === 0) {
        throw new Error('데이터는 길이가 1 이상인 배열 형태이어야 합니다.')
      } 

      if(!data.every(obj => 'text' in obj)) {
        throw new Error('데이터 내에 text 테스트가 없습니다.');
      }

      this.id = id;
      this.data = data;
      
      this.render = function() {
        const $todoListEl = document.querySelector(`#todo-list__${this.id}`);        
        const texts = this.data.map(obj => { 
          return obj.isCompleted ? `<li><s>${obj.text}</s></li>` : `<li>${obj.text}</li>`; 
        } ).join('');

        $todoListEl.innerHTML = texts;
      }

      /**
       * setState 메서드를 정의
       * render 메서드를 내부에서 재호출하는 방식이 아니라했기 때문에 고민
       * 결국, 내부에서 this.data 를 인수로 전달받은 nextData 로 재할당 이후
       * 나머지 작업은 render 메서드와 동일하게 작성되었다.. 
       */ 

      // ❓ 재사용성이라곤 찾아볼 수 없는 구현방식이 아닌가..찝찝하다.
      // ❓ 이 메서드 구현의 진짜 의도를 파악 못한 것 같다.
      this.setState = function(nextData) {
        this.data = nextData;
        const $todoListEl = document.querySelector(`#todo-list__${this.id}`);
        const texts = this.data.map(obj => { 
          return obj.isCompleted ? `<li><s>${obj.text}</s></li>` : `<li>${obj.text}</li>`; 
        } ).join('');

        $todoListEl.innerHTML = texts;
      }
    }

    
    const todoList1 =  new TodoList(data1, 1);
    todoList1.render();
    
    // setState 메서드 적용
    // 변화를 확인하기 위해 타이머 함수 setTimeout 비동기 함수 적용
    setTimeout(() => { todoList1.setState(nextData1) }, 1000);

    const todoList2 =  new TodoList(data2, 2);
    todoList2.render();

    const todoList3 =  new TodoList(data3, 3);
    todoList3.render();
  </script>
</body>
</html>